<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Allison's Block Blast — Game</title>
<style>
  :root{
    --bg1: #ffedf3;
    --pink: #ffd6e6; /* board */
    --block: #cfe9ff; /* blocks */
    --gold1: linear-gradient(90deg,#ffd700,#ffcc33);
    --gold-text: #b8860b;
    --shiny: rgba(255,215,0,0.9);
    --glass: rgba(255,255,255,0.12);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Arial,sans-serif;background:linear-gradient(135deg,#ff80ab 0%,#ffd700 100%);color:#222}
  .app{
    max-width:1100px;margin:24px auto;padding:20px;border-radius:18px;
    background:linear-gradient(180deg,rgba(255,255,255,0.12),rgba(255,255,255,0.02));
    box-shadow:0 10px 30px rgba(0,0,0,0.15);
    border:2px solid rgba(255,215,0,0.18);
  }

  header{
    display:flex;align-items:center;gap:18px;justify-content:space-between;
    padding:8px 12px;margin-bottom:12px;
  }
  .title {
    text-align:left;
  }
  .title h1{
    margin:0;font-size:28px;line-height:1;
    background:linear-gradient(270deg,#ffd700,#ff80ab,#ffd700);
    -webkit-background-clip:text;-webkit-text-fill-color:transparent;
    font-weight:800;
    text-shadow:0 1px 0 rgba(0,0,0,0.08);
  }
  .title h2{
    margin:0;font-size:14px;color:var(--gold-text);font-weight:700;
    letter-spacing:0.06em;
  }

  /* scoreboard */
  .hud{
    display:flex;gap:12px;align-items:center;
  }
  .stat{
    background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    border:2px solid rgba(255,215,0,0.18);
    padding:10px 14px;border-radius:12px;min-width:120px;text-align:center;
    box-shadow:0 6px 18px rgba(255,215,0,0.06);
  }
  .stat h3{margin:0;font-size:12px;color:var(--gold-text);font-weight:700}
  .stat p{margin:6px 0 0;font-size:18px;font-weight:800;color:#fff}

  /* layout */
  .game-row{display:flex;gap:20px;align-items:flex-start;flex-wrap:wrap;justify-content:center}
  /* board */
  .board-wrap{background:var(--pink);padding:14px;border-radius:12px;box-shadow:0 8px 20px rgba(0,0,0,0.12);border:2px solid rgba(255,215,0,0.12)}
  .grid{
    display:grid;grid-template-columns:repeat(9,38px);grid-auto-rows:38px;gap:6px;
    padding:6px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));
  }
  .cell{
    width:38px;height:38px;border-radius:6px;background:transparent;border:2px dashed rgba(255,255,255,0.08);
    display:flex;align-items:center;justify-content:center;position:relative;overflow:visible;
    transition:transform .08s ease;
  }
  .cell.occupied{background:var(--block);border:none;box-shadow:0 6px 12px rgba(0,0,0,0.12), inset 0 -6px 12px rgba(255,255,255,0.08)}
  .cell.preview.valid{outline:3px solid rgba(100,150,255,0.45);box-shadow:0 0 12px rgba(100,150,255,0.15)}
  .cell.preview.invalid{outline:3px solid rgba(255,80,80,0.35);}

  /* upcoming pieces area */
  .pieces{
    display:flex;flex-direction:column;gap:14px;align-items:center;min-width:220px;
  }
  .piece-slot{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));
    padding:12px;border-radius:12px;border:2px solid rgba(255,215,0,0.12);min-width:190px;
    display:flex;align-items:center;gap:10px;justify-content:center;flex-wrap:wrap;
  }
  .piece{
    width:100px;height:60px;background:transparent;display:grid;grid-template-columns:repeat(5,1fr);grid-auto-rows:12px;gap:4px;align-items:center;justify-items:center;
    position:relative;cursor:pointer;border-radius:8px;transition:transform .12s ease,box-shadow .12s;
  }
  .piece.selected{box-shadow:0 8px 30px rgba(255,215,0,0.18);transform:translateY(-4px)}
  .cell-mini{width:12px;height:12px;border-radius:2px;background:var(--block);box-shadow:0 4px 6px rgba(0,0,0,0.08)}
  .controls{display:flex;flex-direction:column;gap:8px;align-items:center}

  .btn{
    background:linear-gradient(90deg,#ffcc33,#ffd700);border:none;padding:8px 12px;border-radius:10px;font-weight:800;color:#3a2a00;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,0.12)
  }
  .btn.secondary{background:transparent;border:2px solid rgba(255,255,255,0.06);color:#fff;font-weight:700}

  /* shiny small labels */
  .label{font-size:12px;color:var(--gold-text);font-weight:700;letter-spacing:0.04em}

  /* instructions modal */
  .modal{
    position:fixed;right:18px;bottom:18px;background:linear-gradient(180deg,rgba(255,255,255,0.96),#fff);color:#222;padding:16px;border-radius:12px;box-shadow:0 18px 40px rgba(0,0,0,0.28);max-width:320px;border:3px solid rgba(255,200,0,0.9);display:none;z-index:2000;
  }
  .modal h3{margin:0 0 8px}
  .modal p{margin:8px 0;font-size:14px;color:#333}
  .modal .close{position:absolute;right:8px;top:8px;background:transparent;border:none;font-weight:800;color:#aa6600;cursor:pointer}

  /* footer / small */
  footer{margin-top:18px;text-align:center;color:var(--gold-text);font-weight:700}
  /* responsive */
  @media(max-width:880px){
    .grid{grid-template-columns:repeat(9,30px);grid-auto-rows:30px}
    .cell{width:30px;height:30px}
    .piece{width:82px;height:60px}
  }
</style>
</head>
<body>
  <div class="app" role="application" aria-label="Allison's Block Blast">
    <header>
      <div class="title">
        <h1>Allison's Life</h1>
        <h2>Softball • Block Blast Game</h2>
      </div>

      <div class="hud" aria-hidden="false">
        <div class="stat" title="Highest score achieved on this browser">
          <h3>High Score</h3>
          <p id="highScore">0</p>
        </div>
        <div class="stat">
          <h3>Score</h3>
          <p id="score">0</p>
        </div>
      </div>
    </header>

    <div class="game-row">
      <!-- Board -->
      <div class="board-wrap" aria-label="Game board">
        <div class="grid" id="grid" role="grid" aria-label="9 by 9 board"></div>
        <div style="margin-top:10px;display:flex;gap:8px;justify-content:center">
          <button class="btn" id="resetBtn">New Game</button>
          <button class="btn secondary" id="shuffleBtn">Shuffle Next (give new 3)</button>
        </div>
      </div>

      <!-- Pieces + Controls -->
      <div class="pieces" aria-hidden="false">
        <div class="label">Upcoming Pieces</div>

        <div class="piece-slot" id="piecesArea" aria-live="polite"></div>

        <div class="controls">
          <button class="btn" id="rotateBtn" title="Rotate selected piece (90°)">Rotate</button>
          <button class="btn secondary" id="deselectBtn">Deselect</button>
          <div style="height:6px"></div>
          <div class="label">Tips</div>
          <div style="font-size:13px;color:#fff;max-width:180px;text-align:center">
            Place cells to score. Complete rows to clear +2 points. Clear whole board +3!
          </div>
        </div>
      </div>
    </div>

    <footer>
      <span style="display:inline-block;padding:6px 12px;border-radius:20px;background:linear-gradient(90deg,#ffd700,#ffcc33);font-weight:800;color:#3a2a00">Shiny • Gold • Light Pink</span>
    </footer>
  </div>

  <!-- instructions modal bottom-right -->
  <div id="modal" class="modal" role="dialog" aria-modal="true" aria-label="Instructions">
    <button class="close" id="closeModal">✕</button>
    <h3>How to play</h3>
    <p>1) You get 3 random shapes. Click a shape to select it, hover the board to preview, then click a cell to place it.</p>
    <p>2) Each cell you place = <strong>+1 point</strong>. Completing a full row clears it and gives <strong>+2 points</strong> per row cleared. Clear the entire board and get an extra <strong>+3 points</strong>.</p>
    <p>3) After you place all 3 shapes a new set of 3 appears. The generator ensures there is at least one way to place all three each turn.</p>
    <p>Tip: plan placements to create full rows — shiny gold rewards await ✨</p>
  </div>

<script>
/* -------------------------
   Game constants & shapes
   ------------------------- */
const ROWS = 9, COLS = 9;
const gridEl = document.getElementById('grid');
const piecesArea = document.getElementById('piecesArea');
const scoreEl = document.getElementById('score');
const highScoreEl = document.getElementById('highScore');

let board = Array.from({length: ROWS}, ()=>Array(COLS).fill(0)); // 0 empty, 1 occupied
let score = 0;
let highScore = Number(localStorage.getItem('allison_highscore') || 0);
highScoreEl.textContent = highScore;

let upcoming = []; // array of piece objects {cells:[{r,c}],color,rotations:[...]}
let selectedIndex = -1;
let selectedRotation = 0;

/* Define base shapes as arrays of (r,c) relative coordinates */
const BASE_SHAPES = [
  // single
  [{r:0,c:0}],
  // 2-cell horizontal
  [{r:0,c:0},{r:0,c:1}],
  // 3-line
  [{r:0,c:0},{r:0,c:1},{r:0,c:2}],
  // 4-line
  [{r:0,c:0},{r:0,c:1},{r:0,c:2},{r:0,c:3}],
  // 2x2 square
  [{r:0,c:0},{r:0,c:1},{r:1,c:0},{r:1,c:1}],
  // L small
  [{r:0,c:0},{r:1,c:0},{r:2,c:0},{r:2,c:1}],
  // T
  [{r:0,c:0},{r:0,c:1},{r:0,c:2},{r:1,c:1}],
  // S shape
  [{r:0,c:1},{r:0,c:2},{r:1,c:0},{r:1,c:1}],
  // plus + (5 cells)
  [{r:0,c:1},{r:1,c:0},{r:1,c:1},{r:1,c:2},{r:2,c:1}],
  // small L 3
  [{r:0,c:0},{r:1,c:0},{r:1,c:1}]
];

/* Utility: rotate coords clockwise 90 deg around (0,0) -> (r,c) -> (c,-r) */
function rotateCells(cells){
  return cells.map(({r,c})=>({r:c, c:-r}));
}
function normalize(cells){
  // translate so min r and min c are 0
  let minR = Math.min(...cells.map(s=>s.r));
  let minC = Math.min(...cells.map(s=>s.c));
  return cells.map(s=>({r:s.r - minR, c:s.c - minC}));
}
function canonicalVariants(base){
  // return unique normalized rotations (0,90,180,270)
  let variants = [];
  let curr = base.map(s=>({r:s.r,c:s.c}));
  for(let i=0;i<4;i++){
    let norm = normalize(curr);
    let key = norm.map(s=>s.r+','+s.c).sort().join('|');
    if(!variants.some(v=>v.key===key)){
      variants.push({key, cells: norm});
    }
    curr = rotateCells(curr);
  }
  return variants.map(v=>v.cells);
}

/* Precompute variants for base shapes */
const SHAPE_VARIANTS = BASE_SHAPES.map(b=>canonicalVariants(b));

/* -------------------------
   Board rendering
   ------------------------- */
function buildGrid(){
  gridEl.innerHTML = '';
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.r = r; cell.dataset.c = c;
      cell.addEventListener('click', onCellClick);
      cell.addEventListener('mousemove', onCellHover);
      cell.addEventListener('mouseleave', clearPreview);
      gridEl.appendChild(cell);
    }
  }
  refreshBoard();
}

function refreshBoard(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const idx = r*COLS + c;
      const el = gridEl.children[idx];
      if(board[r][c]===1){
        el.classList.add('occupied');
      } else {
        el.classList.remove('occupied');
      }
      el.classList.remove('preview','valid','invalid');
      el.style.transform = '';
    }
  }
}

/* -------------------------
   Pieces UI & selection
   ------------------------- */
function renderUpcoming(){
  piecesArea.innerHTML = '';
  upcoming.forEach((p,i)=>{
    const slot = document.createElement('div');
    slot.className = 'piece';
    if(i===selectedIndex) slot.classList.add('selected');
    slot.title = Piece ${i+1} — ${p.cells.length} cell(s);
    // create a mini 5x3 grid to show shape centered
    const miniGrid = document.createElement('div');
    miniGrid.style.display='grid';
    miniGrid.style.gridTemplateColumns='repeat(5,1fr)';
    miniGrid.style.gridAutoRows='12px';
    miniGrid.style.gap='4px';
    miniGrid.style.width='100%';
    miniGrid.style.height='48px';
    miniGrid.style.alignItems='center';miniGrid.style.justifyItems='center';
    // find bounding box of cells for centering
    let maxR = Math.max(...p.cells.map(s=>s.r));
    let maxC = Math.max(...p.cells.map(s=>s.c));
    const w = maxC+1, h = maxR+1;
    // origin offset to center
    const xOff = Math.floor((5 - w)/2);
    const yOff = Math.floor((3 - h)/2)*0; // not used, using rows trick with 12px heights
    // create 5x3 small placeholders
    const miniCount = 5*4; // 5 cols x 4 rows (approx)
    for(let j=0;j<20;j++){
      const d = document.createElement('div');
      d.style.width='14px';d.style.height='12px';
      d.style.borderRadius='2px';
      d.style.background='transparent';
      miniGrid.appendChild(d);
    }
    // fill mini cells for shape
    p.cells.forEach(cell=>{
      const localIdx = (cell.r)*5 + (cell.c + xOff);
      if(localIdx>=0 && localIdx < miniGrid.children.length){
        const d = miniGrid.children[localIdx];
        d.style.background='var(--block)';
        d.style.boxShadow='0 4px 8px rgba(0,0,0,0.08)';
        d.style.borderRadius='2px';
      }
    });

    slot.appendChild(miniGrid);
    slot.addEventListener('click', ()=>{ selectPiece(i); });
    piecesArea.appendChild(slot);
  });
}

/* -------------------------
   Selection & placement preview
   ------------------------- */
function selectPiece(i){
  if(i<0 || i>=upcoming.length) { selectedIndex=-1; selectedRotation=0; renderUpcoming(); return; }
  if(selectedIndex===i){ selectedIndex=-1; selectedRotation=0; } else { selectedIndex=i; selectedRotation=0; }
  renderUpcoming();
  clearPreview();
}

function getSelectedPieceVariants(){
  if(selectedIndex<0) return [];
  return upcoming[selectedIndex].variants;
}

/* When hovering the board show preview relative to hovered cell */
function onCellHover(e){
  if(selectedIndex<0) return;
  const r = Number(e.currentTarget.dataset.r);
  const c = Number(e.currentTarget.dataset.c);
  showPreviewAt(r,c);
}

function clearPreview(){
  document.querySelectorAll('.cell').forEach(el=>el.classList.remove('preview','valid','invalid'));
}

function showPreviewAt(baseR, baseC){
  clearPreview();
  const variants = getSelectedPieceVariants();
  if(!variants || variants.length===0) return;
  const variant = variants[selectedRotation % variants.length];
  let valid = true;
  for(const {r,c} of variant){
    const rr = baseR + r, cc = baseC + c;
    if(rr<0 || rr>=ROWS || cc<0 || cc>=COLS) { valid=false; break;}
    if(board[rr][cc]===1) { valid=false; break;}
  }
  for(const {r,c} of variant){
    const rr = baseR + r, cc = baseC + c;
    if(rr<0 || rr>=ROWS || cc<0 || cc>=COLS) continue;
    const el = gridEl.children[rr*COLS + cc];
    el.classList.add('preview');
    el.classList.add(valid ? 'valid' : 'invalid');
  }
}

/* Place piece if valid */
function onCellClick(e){
  if(selectedIndex<0) return;
  const r = Number(e.currentTarget.dataset.r);
  const c = Number(e.currentTarget.dataset.c);
  const variant = upcoming[selectedIndex].variants[selectedRotation % upcoming[selectedIndex].variants.length];
  // check fit
  let can = true;
  for(const {r:dr,c:dc} of variant){
    const rr = r+dr, cc = c+dc;
    if(rr<0||rr>=ROWS||cc<0||cc>=COLS||board[rr][cc]===1){ can=false; break; }
  }
  if(!can) { // invalid placement feedback
    // small bounce
    e.currentTarget.style.transform = 'scale(0.98)';
    setTimeout(()=>e.currentTarget.style.transform='');
    return;
  }
  // place: mark cells and update score
  let placedCells = 0;
  for(const {r:dr,c:dc} of variant){
    const rr = r+dr, cc = c+dc;
    board[rr][cc] = 1; placedCells++;
  }
  score += placedCells; // +1 per cell placed
  // remove the selected piece from upcoming
  upcoming.splice(selectedIndex,1);
  selectedIndex = -1;
  selectedRotation = 0;
  // after placement check row clears
  const clearedRows = [];
  for(let row=0;row<ROWS;row++){
    if(board[row].every(cell=>cell===1)){
      clearedRows.push(row);
    }
  }
  if(clearedRows.length>0){
    // clear rows (set to 0)
    for(const row of clearedRows){
      for(let cc=0;cc<COLS;cc++) board[row][cc]=0;
    }
    score += 2 * clearedRows.length; // +2 per row
  }

  // check if entire board empty -> +3 bonus
  const anyFilled = board.some(rw=>rw.some(v=>v===1));
  if(!anyFilled){
    score += 3;
  }

  refreshBoard();
  updateScore();
  renderUpcoming();

  // if all 3 used -> generate new triplet and increase difficulty
  if(upcoming.length===0){
    nextRound();
  } else {
    // ensure the remaining upcoming set is still placeable on board (by generator guarantee it should be)
    // but to be safe, if it's not placeable, regenerate new set
    if(!existsPlacementForAll(board, upcoming)){
      nextRound();
    }
  }
}

/* -------------------------
   Scoring & state
   ------------------------- */
function updateScore(){
  scoreEl.textContent = score;
  if(score > highScore){ highScore = score; localStorage.setItem('allison_highscore', highScore); highScoreEl.textContent = highScore; }
}

/* -------------------------
   Shape generation & validation
   ------------------------- */

/* Helper: deep copy board */
function copyBoard(b){
  return b.map(r=>r.slice());
}

/* Fit check */
function canPlaceAt(bd, variant, baseR, baseC){
  for(const {r,c} of variant){
    const rr = baseR + r, cc = baseC + c;
    if(rr<0||rr>=ROWS||cc<0||cc>=COLS) return false;
    if(bd[rr][cc]===1) return false;
  }
  return true;
}

/* Place variant on a copy and return new board */
function placeOnBoard(bd, variant, baseR, baseC){
  const nb = copyBoard(bd);
  for(const {r,c} of variant){
    nb[baseR + r][baseC + c] = 1;
  }
  return nb;
}

/* Brute-force/backtracking validator:
   Given current board and an array of piece objects (each with variants),
   determine if there exists an order, rotation, and placements such that all can be placed.
*/
function existsPlacementForAll(startBoard, pieces){
  // simple DFS trying permutations and placements
  const used = Array(pieces.length).fill(false);

  function dfs(bd, placedCount){
    if(placedCount === pieces.length) return true;
    // choose next piece index not used
    for(let i=0;i<pieces.length;i++){
      if(used[i]) continue;
      used[i]=true;
      // try all variants and all positions
      const p = pieces[i];
      for(const variant of p.variants){
        // tight bounding box iteration to speed: iterate base positions that keep cells in board
        const maxR = ROWS - (Math.max(...variant.map(s=>s.r)) + 1);
        const maxC = COLS - (Math.max(...variant.map(s=>s.c)) + 1);
        for(let r=0;r<=maxR;r++){
          for(let c=0;c<=maxC;c++){
            if(canPlaceAt(bd, variant, r, c)){
              const nb = placeOnBoard(bd, variant, r, c);
              if(dfs(nb, placedCount+1)){
                used[i]=false;
                return true;
              }
            }
          }
        }
      }
      used[i]=false;
    }
    return false;
  }

  return dfs(startBoard, 0);
}

/* Generate a random piece (choose base shape, then random rotation variant) */
function generateRandomPiece(level=1){
  // level can bias towards larger shapes as it increases difficulty
  // choose weighted index: bigger shapes more likely with higher level
  // compute weights based on size
  const weights = SHAPE_VARIANTS.map(v=>Math.min(1+ (v[0].length/2) - 0.2 + level*0.06, 4));
  // normalize and pick
  const tot = weights.reduce((a,b)=>a+b,0);
  let pick = Math.random()*tot;
  let idx = 0;
  for(let i=0;i<weights.length;i++){
    pick -= weights[i];
    if(pick<=0){ idx=i; break;}
  }
  idx = idx ?? (SHAPE_VARIANTS.length-1);
  const variants = SHAPE_VARIANTS[idx];
  // return piece with all rotation variants
  return { baseIndex: idx, variants: variants, cells: variants[0] };
}

/* Generate a set of 3 pieces that is guaranteed placeable somewhere on the current board.
   We will try random triples until the backtracking validator returns true (should be quick).
*/
function generateTripletGuaranteed(bd, level=1, maxAttempts=400){
  for(let attempt=0; attempt<maxAttempts; attempt++){
    let trip = [];
    // bias: as level increases, prefer larger shapes (handled in generateRandomPiece)
    for(let i=0;i<3;i++){
      trip.push(generateRandomPiece(level));
    }
    // validate existence of placement
    if(existsPlacementForAll(bd, trip)){
      return trip;
    }
  }
  // fallback: try simpler guaranteed small pieces (three singles)
  return [
    { baseIndex:0, variants:SHAPE_VARIANTS[0], cells:SHAPE_VARIANTS[0][0]},
    { baseIndex:0, variants:SHAPE_VARIANTS[0], cells:SHAPE_VARIANTS[0][0]},
    { baseIndex:0, variants:SHAPE_VARIANTS[0], cells:SHAPE_VARIANTS[0][0]}
  ];
}

/* -------------------------
   Round logic
   ------------------------- */
let level = 1;
function nextRound(){
  // increase difficulty slightly
  level++;
  // generate new upcoming triplet guaranteed to be placeable
  upcoming = generateTripletGuaranteed(board, level);
  selectedIndex = -1; selectedRotation=0;
  renderUpcoming();
}

/* -------------------------
   Controls & helpers
   ------------------------- */
document.getElementById('resetBtn').addEventListener('click', ()=>{
  if(!confirm('Start a new game? Your score will reset.')) return;
  newGame();
});
document.getElementById('shuffleBtn').addEventListener('click', ()=>{
  // force new triplet (only if upcoming are not placed yet)
  upcoming = generateTripletGuaranteed(board, level);
  selectedIndex=-1;selectedRotation=0;renderUpcoming();
});

document.getElementById('rotateBtn').addEventListener('click', ()=>{
  if(selectedIndex<0) return;
  selectedRotation = (selectedRotation + 1) % upcoming[selectedIndex].variants.length;
  renderUpcoming();
});
document.getElementById('deselectBtn').addEventListener('click', ()=>{ selectedIndex=-1;selectedRotation=0; renderUpcoming(); clearPreview(); });

/* instructions modal */
const modal = document.getElementById('modal');
const closeModal = document.getElementById('closeModal');
document.addEventListener('keydown', (e)=>{ if(e.key === "?" || e.key === "i") modal.style.display = 'block'; if(e.key==='Escape') modal.style.display='none' });
closeModal.addEventListener('click', ()=>modal.style.display='none');
/* open via bottom-right click area: create floating button */
const instrBtn = document.createElement('button');
instrBtn.className='btn';
instrBtn.style.position='fixed';
instrBtn.style.right='18px';
instrBtn.style.bottom='18px';
instrBtn.style.zIndex='1500';
instrBtn.textContent='Instructions';
instrBtn.title='How to play';
instrBtn.addEventListener('click', ()=>{ modal.style.display = modal.style.display === 'block' ? 'none' : 'block'; });
document.body.appendChild(instrBtn);

/* -------------------------
   New game & init
   ------------------------- */
function newGame(){
  board = Array.from({length: ROWS}, ()=>Array(COLS).fill(0));
  score = 0; level = 1; updateScore();
  upcoming = generateTripletGuaranteed(board, level);
  selectedIndex=-1;selectedRotation=0;
  refreshBoard(); renderUpcoming();
}

buildGrid(); newGame();

</script>
</body>
</html>
